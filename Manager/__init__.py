
from Manager.utility import colors
from Manager.utility.Logger.logger import Logger
from Manager.utility.Authenticator.auth import Authenticator
from Manager.utility.RSA.rsa import RSA

from Manager.network.Client import IClient
from Manager.network.Server import IServer

from Manager.network.utils.Packet.CustomPacket import CustomPacket
from Manager.network.utils.Packet.typings.Packet import Packet

from Manager.network.Register import RegisterPacket
from Manager.network.Register import ListeningEvents
from Manager.network.Register import CustomListeningClass

from Manager.network.utils.exceptions.PacketDecompressionError import PacketDecompressionError
from Manager.network.utils.exceptions.PacketDecodingError      import PacketDecodingError
from Manager.network.utils.exceptions.PacketCreationError      import PacketCreationError

from Manager.network.typings.TypeVars import *

import math

__all__ = (
    "colors",
    "Logger",
    "RSA",
    "Authenticator",
    "IClient",
    "IServer",
    "CustomPacket",
    "RegisterPacket",
    "ListeningEvents",
    "CustomListeningClass",
    "format_packet",
    "parse_packet",
    "splitting_package",
)

def format_packet(packet: CustomPacket, content: bytes) -> str:
    """
    Formats the packet data for transmission by combining the packet ID, 
    the content, and the byte-length of the content.
    
    Parameters:
        packet (CustomPacket): The packet to be formatted, containing its ID.
        content (str): The data or message to be included in the packet.
    
    Returns:
        str: A formatted string containing the packet ID, the content, and its byte-length.
    """
    return f"{packet.getId()},{packet.getCompression().compress( content )},{len(content)}"

def parse_packet(context: str) -> Packet:
    """
    Parses the formatted packet string and returns the corresponding CustomPacket object.
    
    Parameters:
        context (str): The formatted packet string generated by format_packet.
    
    Returns:
        Packet: The packet object reconstructed from the formatted data.

    Raises:
        ValueError: If the input context is improperly formatted.
        KeyError: If the packet_name is unknown.
        TypeError: If packet_size is invalid.
        PacketDecodingError: If decoding packet data fails.
        PacketCreationError: If packet instantiation fails.
        PacketDecompressionError: If packet de-compression fails.
        
    """
    
    try:
        packet_name, packet_data, packet_size = context.split(",")
    except ValueError:
        raise ValueError(f"Invalid packet format: '{context}'. Expected 'packet_name,packet_data,packet_size'.")

    packet_codec = RegisterPacket().get_codec(packet_name)
    if packet_codec is None:
        raise KeyError(f"Unknown packet name: '{packet_name}'")
    
    try:
        packet_data = packet_codec.mainclass.getCompression().decompress(packet_data)
    except Exception as e:
        raise PacketDecompressionError(f"Failed to decode packet from hex: {e}")

    try:
        packet_size = int(packet_size)
    except ValueError:
        raise TypeError(f"Invalid packet size: '{packet_size}'. Expected an integer.")
    
    try:
        decoded_packet = packet_codec.decode(packet_data, 0)
    except PacketDecodingError:  # Replace with an actual decoding-related exception
        raise PacketDecodingError(f"Failed to decode packet data: '{packet_data}'")
    
    try:
        packet_instance = packet_codec.mainclass(*decoded_packet)
        return Packet(packet_instance, packet_size)
    except Exception as e:
        raise PacketCreationError(f"Failed to create packet instance: {str(e)}")


def splitting_package(content: str, packet_size: int = 1024) -> list[str]:
    """
    Splits the given content into smaller packets based on a specified packet size.
    
    Each packet will be prefixed with '1' (more packets to come) or '0' (last packet) 
    indicating whether more data follows. The packet size is reduced by 2 to account 
    for the status prefix in each packet.

    Parameters:
        content (str): The data to be split into smaller packets.
        packet_size (int, optional): The size of each packet in bytes (default is 1024).

    Returns:
        list[str]: A list of formatted packets, each containing a prefix (1 or 0) followed by a portion of the content.
    """
    content_size = len(content.encode('utf-8'))
    
    packet_size -= 2
    packets = []

    total_packets = math.ceil( content_size / packet_size )

    for index  in range(total_packets):
        prefix = "0 " if total_packets-1 == index  else "1 "

        packets.append( prefix + content[ index * packet_size : (index + 1) * packet_size ] )

    return packets

def collect_packages(request: str, packets: list[str]) -> str | None:
    """
    Собирает части пакетов в один полный пакет.

    Parameters:
        request (str): Строка с частью пакета.
        packets (list[str]): Список, где хранятся части пакетов.

    Returns:
        (str | None): Полный пакет, если он завершён, иначе None.
    """
    # Извлекаем код из первых двух символов
    c = request[:2]
    # Убираем код из строки
    request = request[2:]
    # Добавляем часть пакета в список
    packets.append(request)

    # Проверяем, завершён ли пакет
    if int(c.strip()) == 1:
        return None  # Пакет ещё не завершён

    # Объединяем все части пакета
    full_packet = "".join(packets)
    packets.clear()  # Очищаем список для следующего пакета
    return full_packet